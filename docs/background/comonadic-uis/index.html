<!DOCTYPE html>
<html>
    <head>
    <meta charset="UTF-8">

    

    <title>bow-arch: Comonadic UIs</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="bow-arch">
    <meta name="keywords" content="functional-programming, monads, monad-transformers, functional-data-structure, swift, bow, xcode, xcode-playgrounds, playgrounds, fp-types, adt, free-monads, tagless-final, mtl, for-comprehension, category-theory, architecture, mobile, apps, application, ios, macos">

    <meta property="og:image" content="/img/poster.png" />
    <meta property="og:title" content="bow-arch: Comonadic UIs" />
    <meta property="og:site_name" content="bow-arch: Comonadic UIs" />
    <meta property="og:url" content="https://arch.bow-swift.io/" />
    <meta property="og:type" content="website" />
    <meta property="og:description" content="bow-arch" />
    <meta property="og:keywords" content="functional-programming, monads, monad-transformers, functional-data-structure, swift, bow, xcode, xcode-playgrounds, playgrounds, fp-types, adt, free-monads, tagless-final, mtl, for-comprehension, category-theory, architecture, mobile, apps, application, ios, macos" />

    <meta name="twitter:text:description" content="bow-arch" />
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@bow_swift">
    <meta name="twitter:creator" content="@bow_swift">
    <meta name="twitter:image" content="/img/poster.png" />

    <meta property="github-info" data-github-owner="bow-swift" data-github-repo="bow-arch" />

    <script defer src="/js/docs.js"></script>

    <!-- Favicon -->
    <link rel="shortcut icon" href="/img/favicon.png">

    <!-- Docs css -->
    <link rel="stylesheet" type="text/css" href="/css/docs.css">
</head>

    <body>
        <div id="site-sidebar" class="site-sidebar">
  <div class="sidebar-brand">
    <a href="/" class="brand" title="Bow-arch">
      <img
        src="/img/bow-arch-brand.svg"
        alt="Bow-arch"
        class="brand-wrapper"
      />
      <span class="title-bold">Bow</span>
      <span>Arch</span>
    </a>
    <button
      id="main-toggle"
      type="button"
      title="Close"
      class="button sidebar-toggle"
    >
      <span class="close"></span>
    </button>
  </div>
  <div class="sidebar-menu">
    
      

      
      
      
      

      
      
      

      

      

    <div class="sidebar-menu-item  ">
       
      <button
        type="button"
        title="Open Quick start"
        class="button drop-nested"
      >
        Quick start
      </button>
      

      <div class="sub-menu">
        
        
        
        <a
          class=""
          href="/docs/quick-start/getting-started/"
          title="Getting started"
        >
          Getting started
        </a>
        
        
        
        <a
          class=""
          href="/docs/quick-start/resources/"
          title="Resources"
        >
          Resources
        </a>
        
      </div>
      
    </div>
    

      
      
      
      

      
      
      

      

      

    <div class="sidebar-menu-item active open">
       
      <button
        type="button"
        title="Open Background"
        class="button drop-nested"
      >
        Background
      </button>
      

      <div class="sub-menu">
        
        
        
        <a
          class=""
          href="/docs/background/overview/"
          title="Overview"
        >
          Overview
        </a>
        
        
        
        <a
          class=""
          href="/docs/background/monads-and-comonads/"
          title="Monads and Comonads"
        >
          Monads and Comonads
        </a>
        
        
        
        <a
          class=""
          href="/docs/background/pairings/"
          title="Pairings"
        >
          Pairings
        </a>
        
        
        
        <a
          class="active"
          href="/docs/background/comonadic-uis/"
          title="Comonadic UIs"
        >
          Comonadic UIs
        </a>
        
      </div>
      
    </div>
    

      
      
      
      

      
      
      

      

      

    <div class="sidebar-menu-item  ">
       
      <button
        type="button"
        title="Open Core concepts"
        class="button drop-nested"
      >
        Core concepts
      </button>
      

      <div class="sub-menu">
        
        
        
        <a
          class=""
          href="/docs/core-concepts/state-and-input/"
          title="State and Input"
        >
          State and Input
        </a>
        
        
        
        <a
          class=""
          href="/docs/core-concepts/view/"
          title="View"
        >
          View
        </a>
        
        
        
        <a
          class=""
          href="/docs/core-concepts/dispatcher/"
          title="Dispatcher"
        >
          Dispatcher
        </a>
        
        
        
        <a
          class=""
          href="/docs/core-concepts/component/"
          title="Component"
        >
          Component
        </a>
        
      </div>
      
    </div>
    

      
      
      
      

      
      
      

      

      

    <div class="sidebar-menu-item  ">
       
      <button
        type="button"
        title="Open Patterns"
        class="button drop-nested"
      >
        Patterns
      </button>
      

      <div class="sub-menu">
        
        
        
        <a
          class=""
          href="/docs/patterns/creating-a-single-component/"
          title="Creating a single component"
        >
          Creating a single component
        </a>
        
        
        
        <a
          class=""
          href="/docs/patterns/creating-nested-components/"
          title="Creating nested components"
        >
          Creating nested components
        </a>
        
      </div>
      
    </div>
    

      
      
      
      

      
      
      

      

      

    <div class="sidebar-menu-item  ">
       
      <button
        type="button"
        title="Open Legal"
        class="button drop-nested"
      >
        Legal
      </button>
      

      <div class="sub-menu">
        
        
        
        <a
          class=""
          href="/docs/legal/credits/"
          title="Credits"
        >
          Credits
        </a>
        
        
        
        <a
          class=""
          href="/docs/legal/license/"
          title="License"
        >
          License
        </a>
        
      </div>
      
    </div>
    
    
  </div>
</div>

        <main id="site-doc" class="site-doc">
    <div class="doc-header">
      <button
        id="menu-toggle"
        type="button"
        class="button doc-toggle"
        title="Toggle">
          <img src="/img/sidebar-icon-open.svg" alt="Toggle" title="Toggle">
      </button>

      <div class="link-container">
        <div class="link-item">
          <a href="https://github.com/bow-swift/bow-arch" title="GitHub repo" target="_blank" rel="noopener noreferrer">
            <span class="strong">GitHub</span>
            <span id="stars-count"></span>
          </a>
        </div>
      </div>

    </div>
    <div class="doc-content">
        <h1 id="comonadic-uis">Comonadic UIs</h1>

<p>Now that we have presented Monads and Comonads, and their Pairing relationship, let’s see how this plays a role on building user interfaces. We will do it following our intuition in an example.</p>

<h2 id="a-swiftui-view">A SwiftUI View</h2>

<p>Let’s build a SwiftUI View according to how it is recommended in the framework documentation. We can create a view to show a stepper:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">StepperView</span><span class="p">:</span> <span class="kt">View</span> <span class="p">{</span>
    <span class="kd">@SwiftUI</span><span class="o">.</span><span class="kt">State</span> <span class="k">var</span> <span class="nv">count</span><span class="p">:</span> <span class="kt">Int</span>
    
    <span class="k">var</span> <span class="nv">body</span><span class="p">:</span> <span class="kd">some</span> <span class="kt">View</span> <span class="p">{</span>
        <span class="kt">HStack</span> <span class="p">{</span>
            <span class="kt">Button</span><span class="p">(</span><span class="s">"-"</span><span class="p">)</span> <span class="p">{</span> <span class="k">self</span><span class="o">.</span><span class="n">count</span> <span class="o">-=</span> <span class="mi">1</span> <span class="p">}</span>
            <span class="kt">Text</span><span class="p">(</span><span class="s">"</span><span class="se">\(</span><span class="n">count</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
            <span class="kt">Button</span><span class="p">(</span><span class="s">"+"</span><span class="p">)</span> <span class="p">{</span> <span class="k">self</span><span class="o">.</span><span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span> <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>A view in SwiftUI must implement the <code class="highlighter-rouge">View</code> protocol, imposing the implementation of a <code class="highlighter-rouge">body</code> property that describes its internal structure. It provides built-in widgets, like <code class="highlighter-rouge">HStack</code>, <code class="highlighter-rouge">Button</code> and <code class="highlighter-rouge">Text</code> to render the view. SwiftUI also provides the <code class="highlighter-rouge">@State</code> property wrapper, which is used to observe state changes and trigger redraws of the view.</p>

<p>We can observe some problems with this approach. First of all, business logic is entangled in presentation logic. We could extract it, but still the view will have to know which logic needs to be invoked. Second, the view is based on mutable state, which could potentially result in difficulties to reason about the code.</p>

<h2 id="view-as-a-function-of-immutable-state">View as a function of immutable state</h2>

<p>Let’s try to rewrite the previous view in a different way:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">enum</span> <span class="kt">StepperInput</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">tapDecrement</span>
    <span class="k">case</span> <span class="n">tapIncrement</span>
<span class="p">}</span>

<span class="kd">struct</span> <span class="kt">StepperView</span><span class="p">:</span> <span class="kt">View</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">count</span><span class="p">:</span> <span class="kt">Int</span>
    <span class="k">let</span> <span class="nv">handle</span><span class="p">:</span> <span class="p">(</span><span class="kt">StepperInput</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Void</span>
    
    <span class="k">var</span> <span class="nv">body</span><span class="p">:</span> <span class="kd">some</span> <span class="kt">View</span> <span class="p">{</span>
        <span class="kt">HStack</span> <span class="p">{</span>
            <span class="kt">Button</span><span class="p">(</span><span class="s">"-"</span><span class="p">)</span> <span class="p">{</span> <span class="k">self</span><span class="o">.</span><span class="nf">handle</span><span class="p">(</span><span class="o">.</span><span class="n">tapDecrement</span><span class="p">)</span> <span class="p">}</span>
            <span class="kt">Text</span><span class="p">(</span><span class="s">"</span><span class="se">\(</span><span class="n">count</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
            <span class="kt">Button</span><span class="p">(</span><span class="s">"+"</span><span class="p">)</span> <span class="p">{</span> <span class="k">self</span><span class="o">.</span><span class="nf">handle</span><span class="p">(</span><span class="o">.</span><span class="n">tapIncrement</span><span class="p">)</span> <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>With this version we have performed some small changes that may have a profound implication:</p>

<ul>
  <li>View is a function of immutable state. We have lost the ability to trigger changes on it, but we will retrieve it later.</li>
  <li>Logic is stripped out of the view; instead, the view communicates events through a function.</li>
</ul>

<p>With this, we have achieved that our View is now a function:</p>

<p><code class="highlighter-rouge">(Int, (StepperInput) -&gt; Void) -&gt; StepperView</code></p>

<p>If we use <code class="highlighter-rouge">S</code> for a generic state, <code class="highlighter-rouge">I</code> for a generic input, and <code class="highlighter-rouge">V</code> for a generic views, we could be modelling all of our views as a function:</p>

<p><code class="highlighter-rouge">view :: (S, (I) -&gt; Void) -&gt; V</code></p>

<h2 id="handling-inputs">Handling inputs</h2>

<p>Let’s focus on the input handling function. Its signature is <code class="highlighter-rouge">(I) -&gt; Void</code>. The only way a function with that signature could be implemented as a pure function is to have an empty body; therefore, we must assume this function is performing side effects.</p>

<p>On the other hand, handling the inputs produced by user interactions on the view should trigger state mutations. In order to perform those state mutations, we may also need to perform side effects. State mutations can be modeled using the State Monad; in particular, if our mutations are not producing any other values, we can model such mutations using <code class="highlighter-rouge">State&lt;S, Void&gt;</code>, given our state has type <code class="highlighter-rouge">S</code>. As for side effects, we can model them using <code class="highlighter-rouge">IO</code>.</p>

<p>Therefore, we could split the original function <code class="highlighter-rouge">(I) -&gt; Void</code> as:</p>

<ul>
  <li><code class="highlighter-rouge">(I) -&gt; IO&lt;Error, State&lt;S, Void&gt;&gt;</code></li>
  <li><code class="highlighter-rouge">(IO&lt;Error, State&lt;S, Void&gt;&gt;) -&gt; IO&lt;Error, Void&gt;</code></li>
  <li><code class="highlighter-rouge">(IO&lt;Error, Void&gt;) -&gt; Void</code></li>
</ul>

<p>As you can see, the output type of a function matches the input of the following; thus, if we compose them, we can have our initial <code class="highlighter-rouge">(I) -&gt; Void</code>.</p>

<p>The first function <code class="highlighter-rouge">(I) -&gt; IO&lt;Error, State&lt;S, Void&gt;&gt;</code> is a function that must be provided to interpret how to map inputs to state mutations. It describes the application logic, and therefore must be provided for each specific case. In Bow Arch, it is modeled as a <code class="highlighter-rouge">StateDispatcher</code>.</p>

<p>The second function has a signature <code class="highlighter-rouge">(IO&lt;Error, State&lt;S, Void&gt;&gt;) -&gt; IO&lt;Error, Void&gt;</code>. If we pay attention to the types of the input an output of this function, we can infer that this function will somehow handle the state transitions, as the <code class="highlighter-rouge">State&lt;S, Void&gt;</code> “disappears”; therefore, it should be applied within the implementation of this function. In Bow ARch, we will refer to this function as the <code class="highlighter-rouge">StateHandler&lt;S&gt;</code>.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">typealias</span> <span class="kt">StateHandler</span><span class="o">&lt;</span><span class="kt">S</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">(</span><span class="kt">IO</span><span class="o">&lt;</span><span class="kt">Error</span><span class="p">,</span> <span class="kt">State</span><span class="o">&lt;</span><span class="kt">S</span><span class="p">,</span> <span class="kt">Void</span><span class="o">&gt;&gt;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">IO</span><span class="o">&lt;</span><span class="kt">Error</span><span class="p">,</span> <span class="kt">Void</span><span class="o">&gt;</span>
</code></pre></div></div>

<p>The third function on this list is a well known function; the sensible implementation for this function would be to <code class="highlighter-rouge">unsafeRun</code> the <code class="highlighter-rouge">IO&lt;Error, Void&gt;</code> value to perform the described side effects.</p>

<h2 id="representing-a-user-interface">Representing a user interface</h2>

<p>If we step back a bit, our view function was:</p>

<p><code class="highlighter-rouge">view :: (S, (I) -&gt; Void) -&gt; V</code></p>

<p>We have seen that <code class="highlighter-rouge">(I) -&gt; Void</code> can be decomposed into three parts, from which we can take the second part to take care of the state transitions; we will see later how we plug in the two other pieces. We can rewrite this function as:</p>

<p><code class="highlighter-rouge">view :: (S, StateHandler&lt;S&gt;) -&gt; V</code></p>

<p>And currying this function would yield:</p>

<p><code class="highlighter-rouge">view :: (S) -&gt; (StateHandler&lt;S&gt;) -&gt; V</code></p>

<p>For convenience, we can create a new structure <code class="highlighter-rouge">UI&lt;S, V&gt;</code>, that is, a <code class="highlighter-rouge">UI</code> is a function that, when provided a way of handling state transitions, will yield a view.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">typealias</span> <span class="kt">UI</span><span class="o">&lt;</span><span class="kt">S</span><span class="p">,</span> <span class="kt">V</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">(</span><span class="kt">StateHandler</span><span class="o">&lt;</span><span class="kt">S</span><span class="o">&gt;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">V</span>
</code></pre></div></div>

<p>So, our view function can be finally rewritten as:</p>

<p><code class="highlighter-rouge">view :: (S) -&gt; UI&lt;S, V&gt;</code></p>

<p>That is, given a state of type <code class="highlighter-rouge">S</code>, it will provide a user interface that handles state transitions of type <code class="highlighter-rouge">S</code> and shows this state on a view of type <code class="highlighter-rouge">V</code>.</p>

<h2 id="describing-the-space-of-possible-uis">Describing the space of possible UIs</h2>

<p>With the changes we did at the beginning we lost the ability to update the state, as we made the view a function of immutable state. We can restore this ability by making use of the Store Comonad.</p>

<p>A Store definition is:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">Store</span><span class="o">&lt;</span><span class="kt">S</span><span class="p">,</span> <span class="kt">A</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">state</span><span class="p">:</span> <span class="kt">S</span>
    <span class="k">let</span> <span class="nv">render</span><span class="p">:</span> <span class="p">(</span><span class="kt">S</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">A</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Our <code class="highlighter-rouge">view</code> function has the same shape as the <code class="highlighter-rouge">render</code> function in Store, and we can restore state handling using the <code class="highlighter-rouge">state</code> property of Store. Therefore, we can put everything together as:</p>

<p><code class="highlighter-rouge">store :: Store&lt;S, UI&lt;S, V&gt;&gt;</code></p>

<p>This store models the space of all possible UIs that we can have with state <code class="highlighter-rouge">S</code> and drawn as a view <code class="highlighter-rouge">V</code>.</p>

<h2 id="performing-state-transitions">Performing state transitions</h2>

<p>So far we are able to model the space of possible states, but how are state mutations applied? We know that Pairings will help in this regard. The pairing function between State and Store is:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="n">pair</span><span class="o">&lt;</span><span class="kt">S</span><span class="p">,</span> <span class="kt">A</span><span class="p">,</span> <span class="kt">B</span><span class="p">,</span> <span class="kt">C</span><span class="o">&gt;</span><span class="p">(</span>
    <span class="n">_</span> <span class="nv">fa</span><span class="p">:</span> <span class="kt">State</span><span class="o">&lt;</span><span class="kt">S</span><span class="p">,</span> <span class="kt">A</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">_</span> <span class="nv">gb</span><span class="p">:</span> <span class="kt">Store</span><span class="o">&lt;</span><span class="kt">S</span><span class="p">,</span> <span class="kt">B</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">_</span> <span class="nv">f</span><span class="p">:</span> <span class="kd">@escaping</span> <span class="p">(</span><span class="kt">A</span><span class="p">,</span> <span class="kt">B</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">C</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">C</span> <span class="p">{</span>
    <span class="k">let</span> <span class="p">(</span><span class="nv">newS</span><span class="p">,</span> <span class="nv">a</span><span class="p">)</span> <span class="o">=</span> <span class="n">fa</span><span class="o">.</span><span class="nf">run</span><span class="p">(</span><span class="n">gb</span><span class="o">.</span><span class="n">state</span><span class="p">)</span>
    <span class="k">let</span> <span class="nv">b</span> <span class="o">=</span> <span class="n">gb</span><span class="o">.</span><span class="nf">render</span><span class="p">(</span><span class="n">newS</span><span class="p">)</span>
    <span class="k">return</span> <span class="nf">f</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>We can write a new function in terms of <code class="highlighter-rouge">pair</code>:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="n">select</span><span class="o">&lt;</span><span class="kt">S</span><span class="p">,</span> <span class="kt">B</span><span class="o">&gt;</span><span class="p">(</span>
    <span class="n">_</span> <span class="nv">fa</span><span class="p">:</span> <span class="kt">State</span><span class="o">&lt;</span><span class="kt">S</span><span class="p">,</span> <span class="kt">Void</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">_</span> <span class="nv">gb</span><span class="p">:</span> <span class="kt">Store</span><span class="o">&lt;</span><span class="kt">S</span><span class="p">,</span> <span class="kt">Store</span><span class="o">&lt;</span><span class="kt">S</span><span class="p">,</span> <span class="kt">B</span><span class="o">&gt;&gt;</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Store</span><span class="o">&lt;</span><span class="kt">S</span><span class="p">,</span> <span class="kt">B</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nf">pair</span><span class="p">(</span><span class="n">fa</span><span class="p">,</span> <span class="n">gb</span><span class="p">)</span> <span class="p">{</span> <span class="n">void</span><span class="p">,</span> <span class="n">store</span> <span class="k">in</span> <span class="n">store</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>As usual, let’s read the types of this function. It receives a state mutation that produces no other value (<code class="highlighter-rouge">State&lt;S, Void&gt;</code>), and a value <code class="highlighter-rouge">Store&lt;S, Store&lt;S, B&gt;&gt;</code>.</p>

<p>If a <code class="highlighter-rouge">Store&lt;S, B&gt;</code> represents the space of possible <code class="highlighter-rouge">B</code> values that can be rendered from a state <code class="highlighter-rouge">S</code>, then <code class="highlighter-rouge">Store&lt;S, Store&lt;S, B&gt;&gt;</code> represents the space of possible spaces of <code class="highlighter-rouge">B</code> values that can be rendered from an <code class="highlighter-rouge">S</code> value. It is as if we were able to inspect all possible future states where we can transition to from the current one we are in, and use the State mutation to <code class="highlighter-rouge">select</code> one of them.</p>

<p>How can we use this now? Well, we haven’t still provided an implementation for our <code class="highlighter-rouge">StateHandler&lt;S&gt;</code> function, and <code class="highlighter-rouge">select</code> is what we need to do its implementation. We can put everything together as a Component:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">Component</span><span class="o">&lt;</span><span class="kt">S</span><span class="p">,</span> <span class="kt">V</span><span class="o">&gt;</span><span class="p">:</span> <span class="kt">ObservableObject</span> <span class="p">{</span>
    <span class="kd">@Published</span> <span class="k">var</span> <span class="nv">store</span><span class="p">:</span> <span class="kt">Store</span><span class="o">&lt;</span><span class="kt">S</span><span class="p">,</span> <span class="kt">UI</span><span class="o">&lt;</span><span class="kt">S</span><span class="p">,</span> <span class="kt">V</span><span class="o">&gt;&gt;</span>
    
    <span class="nf">init</span><span class="p">(</span><span class="nv">store</span><span class="p">:</span> <span class="kt">Store</span><span class="o">&lt;</span><span class="kt">S</span><span class="p">,</span> <span class="kt">UI</span><span class="o">&lt;</span><span class="kt">S</span><span class="p">,</span> <span class="kt">V</span><span class="o">&gt;&gt;</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="n">store</span> <span class="o">=</span> <span class="n">store</span>
    <span class="p">}</span>
    
    <span class="kd">func</span> <span class="nf">explore</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">V</span> <span class="p">{</span>
        <span class="c1">// (1) Extract obtains the UI in the current state</span>
        <span class="k">let</span> <span class="nv">ui</span><span class="p">:</span> <span class="kt">UI</span><span class="o">&lt;</span><span class="kt">S</span><span class="p">,</span> <span class="kt">V</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">store</span><span class="o">.</span><span class="nf">extract</span><span class="p">()</span>
        
        <span class="c1">// (2) We provide an implementation of the StateHandler&lt;S&gt;</span>
        <span class="c1">//     in order to obtain a view of type V</span>
        <span class="k">return</span> <span class="n">ui</span> <span class="p">{</span> <span class="p">(</span><span class="nv">action</span><span class="p">:</span> <span class="kt">IO</span><span class="o">&lt;</span><span class="kt">Error</span><span class="p">,</span> <span class="kt">State</span><span class="o">&lt;</span><span class="kt">S</span><span class="p">,</span> <span class="kt">Void</span><span class="o">&gt;&gt;</span><span class="p">)</span> <span class="k">in</span>
            
            <span class="c1">// (3) When an action is received,</span>
            <span class="c1">//     we access the state mutation</span>
            <span class="n">action</span><span class="o">.</span><span class="n">flatMap</span> <span class="p">{</span> <span class="p">(</span><span class="nv">stateMutation</span><span class="p">:</span> <span class="kt">State</span><span class="o">&lt;</span><span class="kt">S</span><span class="p">,</span> <span class="kt">Void</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">in</span>
                
                <span class="c1">// (4) Use the mutation to select the next store</span>
                <span class="k">let</span> <span class="nv">nextStore</span><span class="p">:</span> <span class="kt">Store</span><span class="o">&lt;</span><span class="kt">S</span><span class="p">,</span> <span class="kt">UI</span><span class="o">&lt;</span><span class="kt">S</span><span class="p">,</span> <span class="kt">V</span><span class="o">&gt;&gt;</span> <span class="o">=</span> <span class="nf">select</span><span class="p">(</span><span class="n">stateMutation</span><span class="p">,</span> <span class="k">self</span><span class="o">.</span><span class="n">store</span><span class="o">.</span><span class="nf">duplicate</span><span class="p">())</span>
                
                <span class="c1">// (5) And finally, we update the Store with the next state</span>
                <span class="c1">//     that will be rendered</span>
                <span class="k">return</span> <span class="kt">IO</span><span class="o">&lt;</span><span class="kt">Error</span><span class="p">,</span> <span class="kt">Void</span><span class="o">&gt;.</span><span class="n">invoke</span> <span class="p">{</span>
                    <span class="k">self</span><span class="o">.</span><span class="n">store</span> <span class="o">=</span> <span class="n">nextStore</span>
                <span class="p">}</span>
            <span class="p">}</span><span class="o">^</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Despite how abstract these concepts are, the process is not very complex. Finally, in order to make sure our SwiftUI rendering updates every time a state transition occurs, we can make:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">ComponentView</span><span class="o">&lt;</span><span class="kt">S</span><span class="p">,</span> <span class="kt">V</span><span class="p">:</span> <span class="kt">View</span><span class="o">&gt;</span><span class="p">:</span> <span class="kt">View</span> <span class="p">{</span>
    <span class="kd">@ObservedObject</span> <span class="k">var</span> <span class="nv">component</span><span class="p">:</span> <span class="kt">Component</span><span class="o">&lt;</span><span class="kt">S</span><span class="p">,</span> <span class="kt">V</span><span class="o">&gt;</span>
    
    <span class="k">var</span> <span class="nv">body</span><span class="p">:</span> <span class="kd">some</span> <span class="kt">View</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="n">component</span><span class="o">.</span><span class="nf">explore</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Calling explore will obtain the current view for the state saved on the Store. When a user interface event occurs, it will be processed in the flow above, will trigger a new Store, and the <code class="highlighter-rouge">ObservedObject</code> property wrapper will notice a change, that will result in a new rendering of the UI.</p>

<h2 id="generalizing-these-ideas">Generalizing these ideas</h2>

<p>So far we have described how these ideas are applicable for State and Store; however, the reasoning can be generalized, as the “magic” of this approach resides on the notion of Pairing between a Monad and a Comonad.</p>

<p>In fact, the <code class="highlighter-rouge">explore</code> function does not need to know it is dealing with State and Store; it just uses a <code class="highlighter-rouge">select</code> function, which is a function that can be derived from <code class="highlighter-rouge">pair</code>. Therefore, <code class="highlighter-rouge">explore</code> can be written as a generic function that operates on a Comonad, and its Pairing Monad.</p>

<p>If we take this approach, we can review our entire reasoning to define the building blocks of the Comonadic UIs approach as using a Monad <code class="highlighter-rouge">M</code> and a Comonad <code class="highlighter-rouge">W</code> that pair with each other:</p>

<ul>
  <li><code class="highlighter-rouge">Handler&lt;M: Monad&gt; :: (IO&lt;Error, M&lt;Void&gt;&gt;) -&gt; IO&lt;Error, Void&gt;</code></li>
  <li><code class="highlighter-rouge">UI&lt;M: Monad, V&gt; :: (Handler&lt;M&gt;) -&gt; V</code></li>
  <li><code class="highlighter-rouge">Component&lt;W: Comonad, M: Monad, V&gt; :: W&lt;UI&lt;M, V&gt;&gt;</code></li>
</ul>

<p>Moreover, we are using <code class="highlighter-rouge">IO</code> to model side effects here, but nothing stops us to abstract over this as well. We could be using other type to deal with side effects. In this case, if we use an abstract <code class="highlighter-rouge">Eff</code> type, the final result is:</p>

<ul>
  <li><code class="highlighter-rouge">Handler&lt;Eff, M&gt; :: (Eff&lt;M&lt;Void&gt;&gt;) -&gt; Eff&lt;Void&gt;</code></li>
  <li><code class="highlighter-rouge">UI&lt;Eff, M, V&gt; :: (Handler&lt;Eff, M&gt;) -&gt; V</code></li>
  <li><code class="highlighter-rouge">Component&lt;Eff, W, M, V&gt; :: W&lt;UI&lt;Eff, M, V&gt;&gt;</code></li>
</ul>

<p>With this model, we can yield different architectures, letting us choose the type we will use to model side effects (<code class="highlighter-rouge">Eff</code>), the type to model UI actions (<code class="highlighter-rouge">M</code>) and the space of possible UIs (<code class="highlighter-rouge">W</code>).</p>

<h2 id="conclusion">Conclusion</h2>

<p>Bow Arch provides a general implementation of this model, and additional syntax sugar over the State-Store pair, which will ease the usage of the library.</p>

<p>The actual implementation is a bit more complex, but not too much; concepts presented here have been simplified for the sake of pedagogy.</p>

<p>Do not worry if you do not get it on the first read. It will take time for the ideas to percolate, and you will discover new things every time you read these docs. An effective way of understanding it is to actually try to write the code, at least in a non-generic way. It will help you see these concepts in practice. And if you get stuck, feel free to open an issue on the library repository, or contact the developers of the library.</p>

    </div>
</main>

    </body>
</html>
