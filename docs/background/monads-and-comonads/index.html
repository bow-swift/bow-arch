<!DOCTYPE html>
<html>
    <head>
    <meta charset="UTF-8">

    

    <title>bow-arch: Monads and Comonads</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="bow-arch">
    <meta name="keywords" content="functional-programming, monads, monad-transformers, functional-data-structure, swift, bow, xcode, xcode-playgrounds, playgrounds, fp-types, adt, free-monads, tagless-final, mtl, for-comprehension, category-theory, architecture, mobile, apps, application, ios, macos">

    <meta property="og:image" content="/img/poster.png" />
    <meta property="og:title" content="bow-arch: Monads and Comonads" />
    <meta property="og:site_name" content="bow-arch: Monads and Comonads" />
    <meta property="og:url" content="https://arch.bow-swift.io/" />
    <meta property="og:type" content="website" />
    <meta property="og:description" content="bow-arch" />
    <meta property="og:keywords" content="functional-programming, monads, monad-transformers, functional-data-structure, swift, bow, xcode, xcode-playgrounds, playgrounds, fp-types, adt, free-monads, tagless-final, mtl, for-comprehension, category-theory, architecture, mobile, apps, application, ios, macos" />

    <meta name="twitter:text:description" content="bow-arch" />
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@bow_swift">
    <meta name="twitter:creator" content="@bow_swift">
    <meta name="twitter:image" content="/img/poster.png" />

    <meta property="github-info" data-github-owner="bow-swift" data-github-repo="bow-arch" />

    <script defer src="/js/docs.js"></script>

    <!-- Favicon -->
    <link rel="shortcut icon" href="/img/favicon.png">

    <!-- Docs css -->
    <link rel="stylesheet" type="text/css" href="/css/docs.css">
</head>

    <body>
        <div id="site-sidebar" class="site-sidebar">
  <div class="sidebar-brand">
    <a href="/" class="brand" title="Bow-arch">
      <img
        src="/img/bow-arch-brand.svg"
        alt="Bow-arch"
        class="brand-wrapper"
      />
      <span class="title-bold">Bow</span>
      <span>Arch</span>
    </a>
    <button
      id="main-toggle"
      type="button"
      title="Close"
      class="button sidebar-toggle"
    >
      <span class="close"></span>
    </button>
  </div>
  <div class="sidebar-menu">
    
      

      
      
      
      

      
      
      

      

      

    <div class="sidebar-menu-item  ">
       
      <button
        type="button"
        title="Open Quick start"
        class="button drop-nested"
      >
        Quick start
      </button>
      

      <div class="sub-menu">
        
        
        
        <a
          class=""
          href="/docs/quick-start/getting-started/"
          title="Getting started"
        >
          Getting started
        </a>
        
        
        
        <a
          class=""
          href="/docs/quick-start/resources/"
          title="Resources"
        >
          Resources
        </a>
        
      </div>
      
    </div>
    

      
      
      
      

      
      
      

      

      

    <div class="sidebar-menu-item active open">
       
      <button
        type="button"
        title="Open Background"
        class="button drop-nested"
      >
        Background
      </button>
      

      <div class="sub-menu">
        
        
        
        <a
          class=""
          href="/docs/background/overview/"
          title="Overview"
        >
          Overview
        </a>
        
        
        
        <a
          class="active"
          href="/docs/background/monads-and-comonads/"
          title="Monads and Comonads"
        >
          Monads and Comonads
        </a>
        
        
        
        <a
          class=""
          href="/docs/background/pairings/"
          title="Pairings"
        >
          Pairings
        </a>
        
        
        
        <a
          class=""
          href="/docs/background/comonadic-uis/"
          title="Comonadic UIs"
        >
          Comonadic UIs
        </a>
        
      </div>
      
    </div>
    

      
      
      
      

      
      
      

      

      

    <div class="sidebar-menu-item  ">
       
      <button
        type="button"
        title="Open Core concepts"
        class="button drop-nested"
      >
        Core concepts
      </button>
      

      <div class="sub-menu">
        
        
        
        <a
          class=""
          href="/docs/core-concepts/state-and-input/"
          title="State and Input"
        >
          State and Input
        </a>
        
        
        
        <a
          class=""
          href="/docs/core-concepts/view/"
          title="View"
        >
          View
        </a>
        
        
        
        <a
          class=""
          href="/docs/core-concepts/dispatcher/"
          title="Dispatcher"
        >
          Dispatcher
        </a>
        
        
        
        <a
          class=""
          href="/docs/core-concepts/component/"
          title="Component"
        >
          Component
        </a>
        
      </div>
      
    </div>
    

      
      
      
      

      
      
      

      

      

    <div class="sidebar-menu-item  ">
       
      <button
        type="button"
        title="Open Patterns"
        class="button drop-nested"
      >
        Patterns
      </button>
      

      <div class="sub-menu">
        
        
        
        <a
          class=""
          href="/docs/patterns/creating-a-single-component/"
          title="Creating a single component"
        >
          Creating a single component
        </a>
        
        
        
        <a
          class=""
          href="/docs/patterns/creating-nested-components/"
          title="Creating nested components"
        >
          Creating nested components
        </a>
        
      </div>
      
    </div>
    

      
      
      
      

      
      
      

      

      

    <div class="sidebar-menu-item  ">
       
      <button
        type="button"
        title="Open Legal"
        class="button drop-nested"
      >
        Legal
      </button>
      

      <div class="sub-menu">
        
        
        
        <a
          class=""
          href="/docs/legal/credits/"
          title="Credits"
        >
          Credits
        </a>
        
        
        
        <a
          class=""
          href="/docs/legal/license/"
          title="License"
        >
          License
        </a>
        
      </div>
      
    </div>
    
    
  </div>
</div>

        <main id="site-doc" class="site-doc">
    <div class="doc-header">
      <button
        id="menu-toggle"
        type="button"
        class="button doc-toggle"
        title="Toggle">
          <img src="/img/sidebar-icon-open.svg" alt="Toggle" title="Toggle">
      </button>

      <div class="link-container">
        <div class="link-item">
          <a href="https://github.com/bow-swift/bow-arch" title="GitHub repo" target="_blank" rel="noopener noreferrer">
            <span class="strong">GitHub</span>
            <span id="stars-count"></span>
          </a>
        </div>
      </div>

    </div>
    <div class="doc-content">
        <h1 id="monads-and-comonads">Monads and Comonads</h1>

<p>Monads are probably the most dreaded concept by newcomers to Functional Programming. They have a lesser known counterpart, Comonads, which happen to have a very special relationship with Monads. This page does not aim to be a tutorial on Monads and Comonads; rather, we will try to build an intuition of what they are, by reading the operations included in these type classes, and the types involved in them.</p>

<h2 id="monads">Monads</h2>

<p>In Category Theory, Monads are defined as <em>Monoids in the Category of Endofunctors</em>. This definition, although correct, is mostly useless in software development. What we need to consider is what are the requirements for something to behave as a Monad.</p>

<p>First thing we need to point out is that Monads cannot be represented as an abstraction in Swift; the Monad type class is an abstraction that works at a Higher Kind level. That is, it must be conformed by a type <code class="highlighter-rouge">F&lt;A&gt;</code>, for all <code class="highlighter-rouge">A</code>. Unfortunately, this is not possible to be expressed in Swift. Bow provides an emulation of Higher Kinded Types that will let us describe this abstraction.</p>

<p>Then, in programming, the Monad type class requires the implementation of two functions:</p>

<ul>
  <li><code class="highlighter-rouge">pure</code> or <code class="highlighter-rouge">return</code>: <code class="highlighter-rouge">(A) -&gt; F&lt;A&gt;</code></li>
  <li><code class="highlighter-rouge">flatMap</code>, <code class="highlighter-rouge">bind</code> or <code class="highlighter-rouge">&gt;&gt;=</code>: <code class="highlighter-rouge">(F&lt;A&gt;, (A) -&gt; F&lt;B&gt;) -&gt; F&lt;B&gt;</code></li>
</ul>

<p>In ocasions, instead of <code class="highlighter-rouge">flatMap</code>, you could implement:</p>

<ul>
  <li><code class="highlighter-rouge">flatten</code>: <code class="highlighter-rouge">(F&lt;F&lt;A&gt;&gt;) -&gt; F&lt;A&gt;</code></li>
</ul>

<p><code class="highlighter-rouge">flatMap</code> and <code class="highlighter-rouge">flatten</code> can be implemented in terms of each other; therefore, in order to have an implementation of a Monad, you must provide implementations of <code class="highlighter-rouge">pure</code>, and <code class="highlighter-rouge">flatMap</code> or <code class="highlighter-rouge">flatten</code>. In Bow, you will always be required to implement <code class="highlighter-rouge">pure</code> and <code class="highlighter-rouge">flatMap</code>.</p>

<p>Let’s look at the types of each required function. <code class="highlighter-rouge">pure</code> is a function <code class="highlighter-rouge">(A) -&gt; F&lt;A&gt;</code>. That is, given any value, the <code class="highlighter-rouge">pure</code> function can lift it to the context of the <code class="highlighter-rouge">Monad</code>. In this sense, we can say that monadic operations “introduce context”.</p>

<p><code class="highlighter-rouge">flatMap</code> is a function <code class="highlighter-rouge">(F&lt;A&gt;, (A) -&gt; F&lt;B&gt;) -&gt; F&lt;B&gt;</code>. It has two arguments: <code class="highlighter-rouge">F&lt;A&gt;</code>, which we can read as “a value in the context of the Monad”; and a function <code class="highlighter-rouge">(A) -&gt; F&lt;B&gt;</code>, which we can read as “a function to produce a new value in the context of the Monad”. Looking at the return type, <code class="highlighter-rouge">F&lt;B&gt;</code>, the only way we can obtain it is by running the function provided as an argument, but to do so, we need a value of type <code class="highlighter-rouge">A</code>. We can somehow obtain an <code class="highlighter-rouge">A</code> from the first argument, given that it exists in the context of the Monad. Therefore, intuitively, the <code class="highlighter-rouge">flatMap</code> operation lets us perform two effects sequentially, when the second (<code class="highlighter-rouge">F&lt;B&gt;</code>) depends on the first (<code class="highlighter-rouge">F&lt;A&gt;</code>). In this way, we can say that Monads let us “chain dependent effects sequentially”.</p>

<p>In summary, from this intuition we can say that Monads introduce context in the operations they are involved, and let us chain effects sequentially.</p>

<h3 id="example">Example</h3>

<p>One example of a Monad that is pervasively used throughout the library is State. <code class="highlighter-rouge">State&lt;S, A&gt;</code> represents a function <code class="highlighter-rouge">(S) -&gt; (S, A)</code>; that is, a function that receives a value of the state model, and produces a tuple with a modification of the provided state, and an output value of type <code class="highlighter-rouge">A</code>. State is used to represent computations that depend on a certain state, without having to thread it explicitly through all operations.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">State</span><span class="o">&lt;</span><span class="kt">S</span><span class="p">,</span> <span class="kt">A</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">run</span><span class="p">:</span> <span class="p">(</span><span class="kt">S</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="kt">S</span><span class="p">,</span> <span class="kt">A</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>It’s instance of the Monad type class (its implementation) is pretty straigthforward. Let’s begin with <code class="highlighter-rouge">pure</code>: given any value of type <code class="highlighter-rouge">A</code>, we can always provide a <code class="highlighter-rouge">State&lt;S, A&gt;</code>, that does not modify the passed state:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">extension</span> <span class="kt">State</span> <span class="p">{</span>
    <span class="kd">static</span> <span class="kd">func</span> <span class="nf">pure</span><span class="p">(</span><span class="n">_</span> <span class="nv">a</span><span class="p">:</span> <span class="kt">A</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">State</span><span class="o">&lt;</span><span class="kt">S</span><span class="p">,</span> <span class="kt">A</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="kt">State</span> <span class="p">{</span> <span class="n">s</span> <span class="nf">in</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>As for <code class="highlighter-rouge">flatMap</code>, we mentioned that, from our intuition, we are sequencing two operations, where the second one depends on the result of the first. That means we should run the first State, obtain the modified state and the output, and feed it to the second:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">extension</span> <span class="kt">State</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="n">flatMap</span><span class="o">&lt;</span><span class="kt">B</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span> <span class="nv">f</span><span class="p">:</span> <span class="kd">@escaping</span> <span class="p">(</span><span class="kt">A</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">State</span><span class="o">&lt;</span><span class="kt">S</span><span class="p">,</span> <span class="kt">B</span><span class="o">&gt;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">State</span><span class="o">&lt;</span><span class="kt">S</span><span class="p">,</span> <span class="kt">B</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="kt">State</span><span class="o">&lt;</span><span class="kt">S</span><span class="p">,</span> <span class="kt">B</span><span class="o">&gt;</span> <span class="p">{</span> <span class="n">s</span> <span class="k">in</span>
            <span class="k">let</span> <span class="p">(</span><span class="nv">newS</span><span class="p">,</span> <span class="nv">a</span><span class="p">)</span> <span class="o">=</span> <span class="k">self</span><span class="o">.</span><span class="nf">run</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
            <span class="k">return</span> <span class="nf">f</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="nf">run</span><span class="p">(</span><span class="n">newS</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="comonads">Comonads</h2>

<p>Similarly, Comonads could be defined as <em>Comonoids in the Category of Endofunctors</em>, which is an equally useless definition in software development. Comonads the dual structure of Monads, obtained by reversing the arrows in Category Theory.</p>

<p>As Monads, Comonads work at the Higher Kind level, and are only possible to be represented using the emulation provided by Bow. They require the implementation of the following requirements:</p>

<ul>
  <li><code class="highlighter-rouge">extract</code>: <code class="highlighter-rouge">(F&lt;A&gt;) -&gt; A</code></li>
  <li><code class="highlighter-rouge">coflatMap</code> or <code class="highlighter-rouge">extend</code>: <code class="highlighter-rouge">(F&lt;A&gt;, (F&lt;A&gt;) -&gt; B) -&gt; F&lt;B&gt;</code></li>
</ul>

<p>Sometimes, instead of <code class="highlighter-rouge">coflatMap</code>, you could implement:</p>

<ul>
  <li><code class="highlighter-rouge">duplicate</code>: <code class="highlighter-rouge">(F&lt;A&gt;) -&gt; F&lt;F&lt;A&gt;&gt;</code></li>
</ul>

<p><code class="highlighter-rouge">coflatMap</code> and <code class="highlighter-rouge">duplicate</code> can be implemented in terms of one another; thus, you need to implement <code class="highlighter-rouge">extract</code>, and <code class="highlighter-rouge">coflatMap</code> or <code class="highlighter-rouge">duplicate</code>, to have an implementation of a Comonad. In Bow, you will always have to implement <code class="highlighter-rouge">extract</code> and <code class="highlighter-rouge">coflatMap</code>.</p>

<p>By now, you may have already noticed some symmetry between Monads and Comonads, but let’s look at the types of the functions in order to build some sort of intuition behind them.</p>

<p><code class="highlighter-rouge">extract</code> is a function <code class="highlighter-rouge">(F&lt;A&gt;) -&gt; A</code>, which, if you pay attention, is just the opposite of <code class="highlighter-rouge">pure</code>. That is, given a value in the context of the Comonad, we are able to extract that value out of the context. This tells us the Comonad represents some kind of space, but it is focused on a specific point of such space, which we can always obtain.</p>

<p><code class="highlighter-rouge">coflatMap</code> is a function <code class="highlighter-rouge">(F&lt;A&gt;, (F&lt;A&gt;) -&gt; B) -&gt; F&lt;B&gt;</code>. That is, we need to return an <code class="highlighter-rouge">F&lt;B&gt;</code>, which as we have mentioned above, can be seen as a space of values of type <code class="highlighter-rouge">B</code>. The only way we can obtain values of type <code class="highlighter-rouge">B</code> is by the function <code class="highlighter-rouge">(F&lt;A&gt;) -&gt; B</code>, but an invocation of this function gives us a single point <code class="highlighter-rouge">B</code> in our space. This suggests we will need to invoke this function potentially multiple times to build the space of <code class="highlighter-rouge">F&lt;B&gt;</code>, and each time, it consumes the context provided by <code class="highlighter-rouge">F&lt;A&gt;</code>. Therefore, <code class="highlighter-rouge">coflatMap</code> lets us perform an operation <code class="highlighter-rouge">(F&lt;A&gt;) -&gt; B</code> that consumes the context of <code class="highlighter-rouge">F&lt;A&gt;</code>, in all posible foci its space of values, to produce a new space of values.</p>

<p>In summary, Comonads let us perform operations that are context-dependent, and extract their focused results.</p>

<h3 id="example-1">Example</h3>

<p>Store is also used extensively in Bow Arch. <code class="highlighter-rouge">Store&lt;S, A&gt;</code> wraps two things: a value of type <code class="highlighter-rouge">S</code>, known as the <code class="highlighter-rouge">state</code>, and a function of type <code class="highlighter-rouge">(S) -&gt; A</code>, known as <code class="highlighter-rouge">render</code>.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">Store</span><span class="o">&lt;</span><span class="kt">S</span><span class="p">,</span> <span class="kt">A</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">state</span><span class="p">:</span> <span class="kt">S</span>
    <span class="k">let</span> <span class="nv">render</span><span class="p">:</span> <span class="p">(</span><span class="kt">S</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">A</span>
<span class="p">}</span>
</code></pre></div></div>

<p>From the intuition we built before, we said a Comonad represents a space of values. Such space is represented by the <code class="highlighter-rouge">render</code> function in the Store. It models all possible <code class="highlighter-rouge">A</code> values that could be potentially rendered by this Store. Also, we mentioned that Comonads are somehow focused on a specific point of such space; in Store, that focus is the <code class="highlighter-rouge">state</code>.</p>

<p>How does its Comonoad instance look like? The <code class="highlighter-rouge">extract</code> function should be easy to implement: just apply the <code class="highlighter-rouge">render</code> function to the current <code class="highlighter-rouge">state</code>:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">extension</span> <span class="kt">Store</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">extract</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">A</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="nf">render</span><span class="p">(</span><span class="k">self</span><span class="o">.</span><span class="n">state</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The implementation for <code class="highlighter-rouge">coflatMap</code> may be a bit more cumbersome to understand. We need to provide a <code class="highlighter-rouge">Store&lt;S, B&gt;</code>. The <code class="highlighter-rouge">state</code> property for such Store is the same <code class="highlighter-rouge">state</code> of the receiver Store, as we have no other way of getting such value.</p>

<p>Regarding the <code class="highlighter-rouge">render</code> function, we need a function <code class="highlighter-rouge">(S) -&gt; B</code>. The only thing we have to obtain a <code class="highlighter-rouge">B</code> is the provided function <code class="highlighter-rouge">(Store&lt;S, A&gt;) -&gt; B</code>. Therefore, we can construct a new Store with the <code class="highlighter-rouge">render</code> function of <code class="highlighter-rouge">Store&lt;S, A&gt;</code>, and pass it to the provided function.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">extension</span> <span class="kt">Store</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="n">coflatMap</span><span class="o">&lt;</span><span class="kt">B</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span> <span class="nv">f</span><span class="p">:</span> <span class="kd">@escaping</span> <span class="p">(</span><span class="kt">Store</span><span class="o">&lt;</span><span class="kt">S</span><span class="p">,</span> <span class="kt">A</span><span class="o">&gt;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">B</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Store</span><span class="o">&lt;</span><span class="kt">S</span><span class="p">,</span> <span class="kt">B</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="kt">Store</span><span class="o">&lt;</span><span class="kt">S</span><span class="p">,</span> <span class="kt">B</span><span class="o">&gt;</span><span class="p">(</span>
            <span class="nv">state</span><span class="p">:</span> <span class="k">self</span><span class="o">.</span><span class="n">state</span><span class="p">,</span>
            <span class="nv">render</span><span class="p">:</span> <span class="p">{</span> <span class="n">s</span> <span class="k">in</span>
                <span class="nf">f</span><span class="p">(</span><span class="kt">Store</span><span class="p">(</span><span class="nv">state</span><span class="p">:</span> <span class="n">s</span><span class="p">,</span> <span class="nv">render</span><span class="p">:</span> <span class="k">self</span><span class="o">.</span><span class="n">render</span><span class="p">))</span>
            <span class="p">})</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>As you can see, the function <code class="highlighter-rouge">(Store&lt;S, A&gt;) -&gt; B</code> is providing us a specific point of the new space in <code class="highlighter-rouge">Store&lt;S, B&gt;</code>, and when we do a <code class="highlighter-rouge">coflatMap</code>, we are potentially exploring all possible contexts (with the new <code class="highlighter-rouge">render</code> function) to build the space of <code class="highlighter-rouge">Store&lt;S, B&gt;</code>.</p>

<p>Stores are focused on a specific state, but also provide methods to change that focus, to render a different point of the space of options they model.</p>

    </div>
</main>

    </body>
</html>
