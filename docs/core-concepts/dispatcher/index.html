<!DOCTYPE html>
<html>
    <head>
    <meta charset="UTF-8">

    

    <title>bow-arch: Dispatcher</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="bow-arch">
    <meta name="keywords" content="functional-programming, monads, monad-transformers, functional-data-structure, swift, bow, xcode, xcode-playgrounds, playgrounds, fp-types, adt, free-monads, tagless-final, mtl, for-comprehension, category-theory, architecture, mobile, apps, application, ios, macos">

    <meta property="og:image" content="/img/poster.png" />
    <meta property="og:title" content="bow-arch: Dispatcher" />
    <meta property="og:site_name" content="bow-arch: Dispatcher" />
    <meta property="og:url" content="https://arch.bow-swift.io/" />
    <meta property="og:type" content="website" />
    <meta property="og:description" content="bow-arch" />
    <meta property="og:keywords" content="functional-programming, monads, monad-transformers, functional-data-structure, swift, bow, xcode, xcode-playgrounds, playgrounds, fp-types, adt, free-monads, tagless-final, mtl, for-comprehension, category-theory, architecture, mobile, apps, application, ios, macos" />

    <meta name="twitter:text:description" content="bow-arch" />
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@bow_swift">
    <meta name="twitter:creator" content="@bow_swift">
    <meta name="twitter:image" content="/img/poster.png" />

    <meta property="github-info" data-github-owner="bow-swift" data-github-repo="bow-arch" />

    <script defer src="/js/docs.js"></script>

    <!-- Favicon -->
    <link rel="shortcut icon" href="/img/favicon.png">

    <!-- Docs css -->
    <link rel="stylesheet" type="text/css" href="/css/docs.css">
</head>

    <body>
        <div id="site-sidebar" class="site-sidebar">
  <div class="sidebar-brand">
    <a href="/" class="brand" title="Bow-arch">
      <img
        src="/img/bow-arch-brand.svg"
        alt="Bow-arch"
        class="brand-wrapper"
      />
      <span class="title-bold">Bow</span>
      <span>Arch</span>
    </a>
    <button
      id="main-toggle"
      type="button"
      title="Close"
      class="button sidebar-toggle"
    >
      <span class="close"></span>
    </button>
  </div>
  <div class="sidebar-menu">
    
      

      
      
      
      

      
      
      

      

      

    <div class="sidebar-menu-item  ">
       
      <button
        type="button"
        title="Open Quick start"
        class="button drop-nested"
      >
        Quick start
      </button>
      

      <div class="sub-menu">
        
        
        
        <a
          class=""
          href="/docs/quick-start/getting-started/"
          title="Getting started"
        >
          Getting started
        </a>
        
        
        
        <a
          class=""
          href="/docs/quick-start/resources/"
          title="Resources"
        >
          Resources
        </a>
        
      </div>
      
    </div>
    

      
      
      
      

      
      
      

      

      

    <div class="sidebar-menu-item  ">
       
      <button
        type="button"
        title="Open Background"
        class="button drop-nested"
      >
        Background
      </button>
      

      <div class="sub-menu">
        
        
        
        <a
          class=""
          href="/docs/background/overview/"
          title="Overview"
        >
          Overview
        </a>
        
        
        
        <a
          class=""
          href="/docs/background/monads-and-comonads/"
          title="Monads and Comonads"
        >
          Monads and Comonads
        </a>
        
        
        
        <a
          class=""
          href="/docs/background/pairings/"
          title="Pairings"
        >
          Pairings
        </a>
        
        
        
        <a
          class=""
          href="/docs/background/comonadic-uis/"
          title="Comonadic UIs"
        >
          Comonadic UIs
        </a>
        
      </div>
      
    </div>
    

      
      
      
      

      
      
      

      

      

    <div class="sidebar-menu-item active open">
       
      <button
        type="button"
        title="Open Core concepts"
        class="button drop-nested"
      >
        Core concepts
      </button>
      

      <div class="sub-menu">
        
        
        
        <a
          class=""
          href="/docs/core-concepts/state-and-input/"
          title="State and Input"
        >
          State and Input
        </a>
        
        
        
        <a
          class=""
          href="/docs/core-concepts/view/"
          title="View"
        >
          View
        </a>
        
        
        
        <a
          class="active"
          href="/docs/core-concepts/dispatcher/"
          title="Dispatcher"
        >
          Dispatcher
        </a>
        
        
        
        <a
          class=""
          href="/docs/core-concepts/component/"
          title="Component"
        >
          Component
        </a>
        
      </div>
      
    </div>
    

      
      
      
      

      
      
      

      

      

    <div class="sidebar-menu-item  ">
       
      <button
        type="button"
        title="Open Patterns"
        class="button drop-nested"
      >
        Patterns
      </button>
      

      <div class="sub-menu">
        
        
        
        <a
          class=""
          href="/docs/patterns/creating-a-single-component/"
          title="Creating a single component"
        >
          Creating a single component
        </a>
        
        
        
        <a
          class=""
          href="/docs/patterns/creating-nested-components/"
          title="Creating nested components"
        >
          Creating nested components
        </a>
        
      </div>
      
    </div>
    

      
      
      
      

      
      
      

      

      

    <div class="sidebar-menu-item  ">
       
      <button
        type="button"
        title="Open Legal"
        class="button drop-nested"
      >
        Legal
      </button>
      

      <div class="sub-menu">
        
        
        
        <a
          class=""
          href="/docs/legal/credits/"
          title="Credits"
        >
          Credits
        </a>
        
        
        
        <a
          class=""
          href="/docs/legal/license/"
          title="License"
        >
          License
        </a>
        
      </div>
      
    </div>
    
    
  </div>
</div>

        <main id="site-doc" class="site-doc">
    <div class="doc-header">
      <button
        id="menu-toggle"
        type="button"
        class="button doc-toggle"
        title="Toggle">
          <img src="/img/sidebar-icon-open.svg" alt="Toggle" title="Toggle">
      </button>

      <div class="link-container">
        <div class="link-item">
          <a href="https://github.com/bow-swift/bow-arch" title="GitHub repo" target="_blank" rel="noopener noreferrer">
            <span class="strong">GitHub</span>
            <span id="stars-count"></span>
          </a>
        </div>
      </div>

    </div>
    <div class="doc-content">
        <h1 id="dispatcher">Dispatcher</h1>

<p>Inputs in the user interface need to be transformed into actions that trigger state changes. That is the responsibility of the Dispatcher: take inputs and transform them into actions that modify the state.</p>

<p>Dispatchers have three parameters:</p>

<ul>
  <li><strong>Environment</strong>: represents the dependencies we need to perform the actions for the received inputs.</li>
  <li><strong>State</strong>: represents the type of the state the dispatcher can modify when an input is received.</li>
  <li><strong>Input</strong>: represents the type of inputs the dispatcher is able to handle.</li>
</ul>

<p>Internally, a dispatcher is a function from the input type, to an array of side-effectful actions that depend on an environment and mutate a state; that is:</p>

<p><code class="highlighter-rouge">(I) -&gt; [EnvIO&lt;E, Error, State&lt;S, Void&gt;&gt;]</code></p>

<p>where:</p>

<ul>
  <li><code class="highlighter-rouge">I</code> is the input type.</li>
  <li><code class="highlighter-rouge">EnvIO</code> is a type to model side-effectful operations that depend on an environment.</li>
  <li><code class="highlighter-rouge">E</code> is the environment type.</li>
  <li><code class="highlighter-rouge">State</code> is a monad that models state-based computations.</li>
  <li><code class="highlighter-rouge">S</code> is the state type.</li>
</ul>

<p>Each action in the array will trigger a UI refresh; this is because some inputs may trigger a UI update, then do a long-running task, and finally trigger a new UI update to show the final result.</p>

<p>Nonetheless, we can create dispatchers for actions that involve single UI updates, or even ones that are side-effect free, with the following methods:</p>

<ul>
  <li><code class="highlighter-rouge">pure</code>: lets us create side-effect free dispatchers that have no dependencies and state modification is pure.</li>
  <li><code class="highlighter-rouge">effectful</code>: lets us create single action dispatchers that may have dependencies and require side effects to modify the state.</li>
  <li><code class="highlighter-rouge">workflow</code>: lets us create side-effectful dispatchers that may have dependencies and perform multiple UI updates.</li>
</ul>

<h2 id="examples">Examples</h2>

<h3 id="pure-dispatcher">Pure Dispatcher</h3>

<p>Incrementing or decrementing the count of a stepper is a pure state modification, so we can create a dispatcher like:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">enum</span> <span class="kt">StepperInput</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">tapDecrement</span>
    <span class="k">case</span> <span class="n">tapIncrement</span>
<span class="p">}</span>

<span class="kd">typealias</span> <span class="kt">StepperDispatcher</span> <span class="o">=</span> <span class="kt">StateDispatcher</span><span class="o">&lt;</span><span class="kt">Any</span><span class="p">,</span> <span class="kt">Int</span><span class="p">,</span> <span class="kt">StepperInput</span><span class="o">&gt;</span>

<span class="k">let</span> <span class="nv">stepperDispatcher</span> <span class="o">=</span> <span class="kt">StepperDispatcher</span><span class="o">.</span><span class="n">pure</span> <span class="p">{</span> <span class="n">input</span> <span class="k">in</span>
    <span class="k">switch</span> <span class="n">input</span> <span class="p">{</span>
    <span class="k">case</span> <span class="o">.</span><span class="nv">tapDecrement</span><span class="p">:</span>
        <span class="k">return</span> <span class="o">.</span><span class="n">modify</span> <span class="p">{</span> <span class="n">count</span> <span class="k">in</span> <span class="n">count</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">}</span><span class="o">^</span>
    <span class="k">case</span> <span class="o">.</span><span class="nv">tapIncrement</span><span class="p">:</span>
        <span class="k">return</span> <span class="o">.</span><span class="n">modify</span> <span class="p">{</span><span class="err"> </span><span class="n">count</span> <span class="k">in</span> <span class="n">count</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">}</span><span class="o">^</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="effectful-dispatcher">Effectful Dispatcher</h2>

<p>Rolling a die is a side-effectful action, as it includes randomness. We can capture randomness in a dependency:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">protocol</span> <span class="kt">Randomness</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="n">getInt</span><span class="o">&lt;</span><span class="kt">E</span><span class="o">&gt;</span><span class="p">(</span><span class="k">in</span> <span class="nv">range</span><span class="p">:</span> <span class="kt">ClosedRange</span><span class="o">&lt;</span><span class="kt">Int</span><span class="o">&gt;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">EnvIO</span><span class="o">&lt;</span><span class="kt">E</span><span class="p">,</span> <span class="kt">Error</span><span class="p">,</span> <span class="kt">Int</span><span class="o">&gt;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Then, we can create our dispatcher as:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">enum</span> <span class="kt">DieInput</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">roll</span>
<span class="p">}</span>

<span class="kd">struct</span> <span class="kt">Die</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">number</span><span class="p">:</span> <span class="kt">Int</span>
<span class="p">}</span>

<span class="kd">typealias</span> <span class="kt">DieDispatcher</span> <span class="o">=</span> <span class="kt">StateDispatcher</span><span class="o">&lt;</span><span class="kt">Randomness</span><span class="p">,</span> <span class="kt">Die</span><span class="p">,</span> <span class="kt">DieInput</span><span class="o">&gt;</span>

<span class="k">let</span> <span class="nv">dieDispatcher</span> <span class="o">=</span> <span class="kt">DieDispatcher</span><span class="o">.</span><span class="n">effectful</span> <span class="p">{</span><span class="err"> </span><span class="n">input</span> <span class="k">in</span>
    <span class="k">switch</span> <span class="n">input</span> <span class="p">{</span>
    <span class="k">case</span> <span class="o">.</span><span class="nv">roll</span><span class="p">:</span>
        <span class="k">return</span> <span class="kt">EnvIO</span><span class="o">.</span><span class="n">accessM</span> <span class="p">{</span><span class="err"> </span><span class="n">random</span> <span class="k">in</span> <span class="n">random</span><span class="o">.</span><span class="nf">getInt</span><span class="p">(</span><span class="nv">in</span><span class="p">:</span> <span class="mi">1</span> <span class="o">...</span> <span class="mi">6</span><span class="p">)</span> <span class="p">}</span>
            <span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="n">n</span> <span class="k">in</span>
                <span class="o">.</span><span class="nf">set</span><span class="p">(</span><span class="kt">Die</span><span class="p">(</span><span class="nv">number</span><span class="p">:</span> <span class="n">n</span><span class="p">))</span><span class="o">^</span>
            <span class="p">}</span><span class="o">^</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="workflow-dispatcher">Workflow Dispatcher</h3>

<p>Finally, we can create a dispatcher that triggers multiple UI updates. For instance, we may show a loading indicator, fetch data from the network, and then show it in the UI.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Dependencies</span>
<span class="kd">protocol</span> <span class="kt">Network</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="n">load</span><span class="o">&lt;</span><span class="kt">E</span><span class="o">&gt;</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">EnvIO</span><span class="o">&lt;</span><span class="kt">E</span><span class="p">,</span> <span class="kt">Error</span><span class="p">,</span> <span class="kt">Data</span><span class="o">&gt;</span>
<span class="p">}</span>

<span class="c1">// State</span>
<span class="kd">enum</span> <span class="kt">ScreenState</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">loading</span>
    <span class="k">case</span> <span class="nf">loaded</span><span class="p">(</span><span class="kt">Data</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Input</span>
<span class="kd">enum</span> <span class="kt">ScreenInput</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">fetchData</span>
<span class="p">}</span>

<span class="c1">// Dispatcher</span>
<span class="kd">typealias</span> <span class="kt">ScreenDispatcher</span> <span class="o">=</span> <span class="kt">StateDispatcher</span><span class="o">&lt;</span><span class="kt">Network</span><span class="p">,</span> <span class="kt">ScreenState</span><span class="p">,</span> <span class="kt">ScreenInput</span><span class="o">&gt;</span>

<span class="kd">func</span> <span class="nf">showLoading</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">EnvIO</span><span class="o">&lt;</span><span class="kt">Network</span><span class="p">,</span> <span class="kt">Error</span><span class="p">,</span> <span class="kt">State</span><span class="o">&lt;</span><span class="kt">ScreenState</span><span class="p">,</span> <span class="kt">Void</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
    <span class="kt">EnvIO</span><span class="o">.</span><span class="nf">pure</span><span class="p">(</span><span class="o">.</span><span class="nf">set</span><span class="p">(</span><span class="o">.</span><span class="n">loading</span><span class="p">)</span><span class="o">^</span><span class="p">)</span><span class="o">^</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">showLoadedData</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">EnvIO</span><span class="o">&lt;</span><span class="kt">Network</span><span class="p">,</span> <span class="kt">Error</span><span class="p">,</span> <span class="kt">State</span><span class="o">&lt;</span><span class="kt">ScreenState</span><span class="p">,</span> <span class="kt">Void</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">network</span> <span class="o">=</span> <span class="kt">EnvIO</span><span class="o">&lt;</span><span class="kt">Network</span><span class="p">,</span> <span class="kt">Error</span><span class="p">,</span> <span class="kt">Network</span><span class="o">&gt;.</span><span class="k">var</span><span class="p">()</span>
    <span class="k">let</span> <span class="nv">data</span> <span class="o">=</span> <span class="kt">EnvIO</span><span class="o">&lt;</span><span class="kt">Network</span><span class="p">,</span> <span class="kt">Error</span><span class="p">,</span> <span class="kt">Data</span><span class="o">&gt;.</span><span class="k">var</span><span class="p">()</span>
    
    <span class="k">return</span> <span class="nf">binding</span><span class="p">(</span>
        <span class="nf">continueOn</span><span class="p">(</span><span class="o">.</span><span class="nf">global</span><span class="p">(</span><span class="nv">qos</span><span class="p">:</span> <span class="o">.</span><span class="n">background</span><span class="p">)),</span>
        <span class="n">network</span> <span class="o">&lt;-</span> <span class="o">.</span><span class="nf">ask</span><span class="p">(),</span>
        <span class="n">data</span> <span class="o">&lt;-</span> <span class="n">network</span><span class="o">.</span><span class="k">get</span><span class="o">.</span><span class="nf">load</span><span class="p">(),</span>
        <span class="nv">yield</span><span class="p">:</span> <span class="o">.</span><span class="nf">set</span><span class="p">(</span><span class="o">.</span><span class="nf">loaded</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="k">get</span><span class="p">))</span><span class="o">^</span>
    <span class="p">)</span><span class="o">^</span>
<span class="p">}</span>

<span class="k">let</span> <span class="nv">screenDispatcher</span> <span class="o">=</span> <span class="kt">ScreenDispatcher</span><span class="o">.</span><span class="n">workflow</span> <span class="p">{</span><span class="err"> </span><span class="n">input</span> <span class="k">in</span>
    <span class="k">switch</span> <span class="n">input</span> <span class="p">{</span>
    <span class="k">case</span> <span class="o">.</span><span class="nv">fetchData</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="nf">showLoading</span><span class="p">(),</span>
            <span class="nf">showLoadedData</span><span class="p">()</span>
        <span class="p">]</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="combining-dispatchers">Combining Dispatchers</h2>

<p>As long as two dispatchers share the same type parameters, they can be combined, as they conform to <code class="highlighter-rouge">Semigroup</code>.</p>

<p>If they don’t have the same type parameters, they can be transformed using the <code class="highlighter-rouge">widen</code> method, which needs the following:</p>

<ul>
  <li>A function to extract the environment from a parent environment.</li>
  <li>A lens to extract the state from a parent state.</li>
  <li>A prism to extract the input from a parent input.</li>
</ul>

<p>For instance, consider the <code class="highlighter-rouge">screenDispatcher</code> above needs to be combined with a parent dispatcher that works on more general environment, state and input:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">Dependencies</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">network</span><span class="p">:</span> <span class="kt">Network</span>
    <span class="k">let</span> <span class="nv">database</span><span class="p">:</span> <span class="kt">Database</span>
<span class="p">}</span>

<span class="kd">struct</span> <span class="kt">ParentState</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">screen</span><span class="p">:</span> <span class="kt">ScreenState</span>
    <span class="k">let</span> <span class="nv">other</span><span class="p">:</span> <span class="kt">OtherState</span>
<span class="p">}</span>

<span class="kd">enum</span> <span class="kt">ParentInput</span> <span class="p">{</span>
    <span class="k">case</span> <span class="nf">screen</span><span class="p">(</span><span class="kt">ScreenInput</span><span class="p">)</span>
    <span class="k">case</span> <span class="nf">other</span><span class="p">(</span><span class="kt">OtherInput</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">typealias</span> <span class="kt">ParentDispatcher</span> <span class="o">=</span> <span class="kt">StateDispatcher</span><span class="o">&lt;</span><span class="kt">Dependencies</span><span class="p">,</span> <span class="kt">ParentState</span><span class="p">,</span> <span class="kt">ParentInput</span><span class="o">&gt;</span>
</code></pre></div></div>

<p>First, we need to create a lens and a prism to focus on the state and input of our child dispatcher:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">screenLens</span> <span class="o">=</span> <span class="kt">Lens</span><span class="o">&lt;</span><span class="kt">ParentState</span><span class="p">,</span> <span class="kt">ScreenState</span><span class="o">&gt;</span><span class="p">(</span>
    <span class="nv">get</span><span class="p">:</span> <span class="p">{</span><span class="err"> </span><span class="n">parent</span> <span class="k">in</span> <span class="n">parent</span><span class="o">.</span><span class="n">screen</span> <span class="p">},</span>
    <span class="nv">set</span><span class="p">:</span> <span class="p">{</span> <span class="n">parent</span><span class="p">,</span> <span class="n">newScreen</span> <span class="k">in</span> <span class="kt">ParentState</span><span class="p">(</span><span class="nv">screen</span><span class="p">:</span> <span class="n">newScreen</span><span class="p">,</span> <span class="nv">other</span><span class="p">:</span> <span class="n">parent</span><span class="o">.</span><span class="n">other</span><span class="p">)</span> <span class="p">}</span>
<span class="p">)</span>

<span class="kd">extension</span> <span class="kt">ParentInput</span><span class="p">:</span> <span class="kt">AutoPrism</span> <span class="p">{}</span>
<span class="k">let</span> <span class="nv">screenPrism</span> <span class="o">=</span> <span class="kt">ParentInput</span><span class="o">.</span><span class="nf">prism</span><span class="p">(</span><span class="nv">for</span><span class="p">:</span> <span class="kt">ParentInput</span><span class="o">.</span><span class="n">screen</span><span class="p">)</span>
</code></pre></div></div>

<p>Then, we can widen our <code class="highlighter-rouge">screenDispatcher</code> to have the same type parameters as the parent:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">widenScreenDispatcher</span><span class="p">:</span> <span class="kt">ParentDispatcher</span> <span class="o">=</span> <span class="n">screenDispatcher</span><span class="o">.</span><span class="nf">widen</span><span class="p">(</span>
    <span class="nv">transformEnvironment</span><span class="p">:</span> <span class="p">{</span> <span class="n">dependencies</span> <span class="k">in</span> <span class="n">dependencies</span><span class="o">.</span><span class="n">network</span> <span class="p">},</span>
    <span class="nv">transformState</span><span class="p">:</span> <span class="n">screenLens</span><span class="p">,</span>
    <span class="nv">transformInput</span><span class="p">:</span> <span class="n">screenPrism</span>
<span class="p">)</span>
</code></pre></div></div>

<p>And finally, we can combine both dispatchers:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">appDispatcher</span> <span class="o">=</span> <span class="n">parentDispatcher</span><span class="o">.</span><span class="nf">combine</span><span class="p">(</span><span class="n">widenScreenDispatcher</span><span class="p">)</span>
</code></pre></div></div>

<p>This lets us write very focused dispatchers that only receive what they need to perform their job, separate our concerns properly, and then have powerful ways to compose them into a single dispatcher that manages the logic of our application.</p>

    </div>
</main>

    </body>
</html>
